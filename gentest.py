import logging
import os
import re
import sys
from dataclasses import dataclass
from typing import Optional

import click
from linkml_runtime.linkml_model import TypeDefinition
from linkml_runtime.linkml_model.meta import ClassDefinition, EnumDefinition, SlotDefinition
from linkml_runtime.utils.formatutils import camelcase, lcamelcase

from linkml._version import __version__
from linkml.generators.common.naming import NameCompatibility, NamingProfiles
from linkml.utils.generator import Generator, shared_arguments


# Mapping of schema types to GraphQL types
known_types = {
    'string': 'String',
    'integer': 'Int',
    'boolean': 'Boolean',
    'float': 'Float',
}


@dataclass
class TestGenerator(Generator):
    # ClassVars
    generatorname = os.path.basename(__file__)
    generatorversion = "0.1.1"
    valid_formats = ["graphql"]
    visit_all_class_slots = True
    uses_schemaloader = True
    requires_metamodel = False

    strict_naming: bool = False
    _permissible_value_valid_characters = re.compile("^[_A-Za-z][_0-9A-Za-z]*?$")

    def _output(self, msg) -> str:
        print(msg, file=sys.stderr, flush=True)
        return msg + '\n'

    def __post_init__(self):
        self.name_compatiblity = NameCompatibility(profile=NamingProfiles.graphql, do_not_fix=self.strict_naming)
        super().__post_init__()

    def visit_schema(self, **kwargs) -> str:
        #msg = 'visit_schema called'
        #return self._output(msg)
        return '# Generated by TestGenerator\n\n'

    def end_schema(self, **kwargs) -> str:
        #msg = 'end_schema called'
        #return self._output(msg)
        return ''

    def visit_class(self, cls: ClassDefinition) -> str:
        #msg = f'visit_class "{cls.name}" called {cls}'
        base = f'interface {cls.name}' if cls.mixin else f'type {cls.name}'
        if cls.mixins:
            base = base + ' implements ' + ' & '.join(cls.mixins)
        return base + ' {\n'

    def end_class(self, cls: ClassDefinition) -> str:
        #msg = f'end_class called {cls}'
        #return self._output(msg)
        return "}\n\n"

    def visit_class_slot(self, cls: ClassDefinition, aliased_slot_name: str, slot: SlotDefinition) -> str:
        if slot.identifier:
            type_spec = 'ID'
        else:
            type_spec = known_types.get(slot.range) or slot.range
        if slot.multivalued:
            type_spec = f'[{type_spec}]'
        if slot.required:
            type_spec += '!'
        return f'    {aliased_slot_name}: {type_spec}\n'

        msg = f'visit_class_slot "{cls.name}.{slot.name}" ("{aliased_slot_name}") called {cls}, {aliased_slot_name}, {slot}'
        if slot.multivalued:
            if slot.inlined:
                if slot.inlined_as_list:
                    mode = 'LIST'
                else:
                    mode = 'DICT'
                msg = f'visit_class_slot "{cls.name}.{slot.name}" ("{aliased_slot_name}") MULTIVALUED, INLINED, {mode}, range: {slot.range} called {cls}, {aliased_slot_name}, {slot}'
            else:
                msg = f'visit_class_slot "{cls.name}.{slot.name}" ("{aliased_slot_name}") MULTIVALUED, LIST OF KEYS, range: {slot.range} called {cls}, {aliased_slot_name}, {slot}'
        else:
            msg = f'visit_class_slot "{cls.name}.{slot.name}" ("{aliased_slot_name}"), range: {slot.range} called {cls}, {aliased_slot_name}, {slot}'

        return self._output(msg)

    def visit_enum(self, enum: EnumDefinition):
        return f'enum {enum.name} {{\n' + '\n'.join(
            '    ' + key for key in enum.permissible_values
        ) + '\n}\n\n'
        return f'# enum {enum.name}\n'
        msg = f'visit_enum called {enum}'
        return self._output(msg)

    def visit_type(self, typ: TypeDefinition) -> Optional[str]:
        if typ.name not in known_types:
            return f'scalar {typ.name}\n'
        return
        msg = f'visit_type called {typ}'
        return self._output(msg)


@shared_arguments(TestGenerator)
@click.command(name="test")
@click.option(
    "--strict-naming",
    is_flag=True,
    show_default=True,
    help="Treat warnings about invalid names or schema elements as errors.",
)
@click.version_option(__version__, "-V", "--version")
def cli(yamlfile, **args):
    """Generate graphql representation of a LinkML model"""
    generator = TestGenerator(yamlfile, **args)
    print(generator.serialize(**args))


if __name__ == "__main__":
    cli()
