"""
Based on the LinkML GraphQL generator, this module generates a GraphQL schema
from a LinkML schema definition. It is specialized for use with the LinkML
schemata that are used by DataLad and INM7, that means:

- There is no name rewriting, all names are used as is.
- There is a union of `Thing` and all its subclasses. This is used in most
  places, where `Thing` is used in the LinkML schema.
- The `relations`-slots have the type 'String' (alternatively, they could be
  a union of `Thing` and all subclasses of `Thing`, that would allow to inline
  objects, but would make queries complicated).
- Identifier slots, i.e., `pid`, are always of type `ID`.

"""
from __future__ import annotations

import logging
import os
import re
import sys
from dataclasses import dataclass

from linkml.utils.generator import Generator
from linkml_runtime.linkml_model import TypeDefinition
from linkml_runtime.linkml_model.meta import ClassDefinition, EnumDefinition, SlotDefinition


# Mapping of schema types to GraphQL types
known_types = {
    'string': 'String',
    'integer': 'Int',
    'boolean': 'Boolean',
    'float': 'Float',
}


@dataclass
class GraphQLGenerator(Generator):
    # ClassVars
    generatorname = os.path.basename(__file__)
    generatorversion = "0.0.1"
    valid_formats = ["graphql"]
    visit_all_class_slots = True
    uses_schemaloader = True
    requires_metamodel = False

    strict_naming: bool = False
    _permissible_value_valid_characters = re.compile("^[_A-Za-z][_0-9A-Za-z]*?$")

    def __post_init__(self):
        super().__post_init__()

    def visit_schema(self, **kwargs) -> str:
        return f'# Generated by {self.generatorname} version {self.generatorversion}\n\n'

    def end_schema(self, **kwargs) -> str | None:
        return

    def visit_class(self, cls: ClassDefinition) -> str:
        base = f'interface {cls.name}' if cls.mixin else f'type {cls.name}'
        if cls.mixins:
            base = base + ' implements ' + ' & '.join(cls.mixins)
        return base + ' {\n'

    def end_class(self, cls: ClassDefinition) -> str:
        return "}\n\n"

    def visit_class_slot(
        self,
        cls: ClassDefinition,
        aliased_slot_name: str,
        slot: SlotDefinition
    ) -> str | None:
        if slot.identifier:
            type_spec = 'ID'
        elif aliased_slot_name == 'relations' and slot.multivalued and slot.range == 'Thing':
            type_spec = 'String'
        else:
            type_spec = known_types.get(slot.range) or slot.range
        if slot.multivalued:
            type_spec = f'[{type_spec}]'
        if slot.required:
            type_spec += '!'
        return f'    {aliased_slot_name}: {type_spec}\n'

    def visit_enum(self, enum: EnumDefinition) -> str | None:
        if enum.permissible_values:
            return f'enum {enum.name} {{\n' + '\n'.join(
                '    ' + key for key in enum.permissible_values
            ) + '\n}\n\n'
        logging.warning(
            f'Enumeration {enum.name} using `reachable_from` instead of `permissible_values` '
            + 'to specify permissible values is not supported yet.'
            + 'Enumeration {enum.name} will be silently ignored!!'
        )

    def visit_type(self, typ: TypeDefinition) -> str | None:
        if typ.name not in known_types:
            return f'scalar {typ.name}\n\n'


def generate_graphql_schema(yaml_file: str, **kwargs) -> str:
    generator = GraphQLGenerator(yaml_file)
    return generator.serialize(**kwargs)


if __name__ == "__main__":
    print(generate_graphql_schema(sys.argv[1]))
