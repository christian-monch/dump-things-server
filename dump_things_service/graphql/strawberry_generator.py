"""
Based on the LinkML GraphQL generator, this module generates a GraphQL schema
from a LinkML schema definition. It is specialized for use with the LinkML
schemata that are used by DataLad and INM7, that means:

- There is no name rewriting, all names are used as is.
- Identifier slots, i.e., `pid`, are always of type `ID`.
- There is a union of `Thing` and all its subclasses, named 'AllThings'.
  This is used in most places, where `Thing` is used in the LinkML schema.
- The `relations`-slots have the type 'AllThings'. This allows to inline
  objects.

"""
from __future__ import annotations

import os
import re
import sys
from dataclasses import dataclass
from pathlib import Path

from linkml.utils.generator import Generator
from linkml_runtime.linkml_model import (
    TypeDefinition,
    SchemaDefinition,
)
from linkml_runtime.linkml_model.meta import (
    ClassDefinition,
    EnumDefinition,
    SlotDefinition,
)


# Mapping of schema types to Python types
known_types = {
    'string': 'str',
    'integer': 'int',
    'boolean': 'bool',
    'float': 'float',
    'double': 'float',
}


thing_union_name = 'AllThings'
record_union_name = 'AllRecords'


header_template = """# Generated by {name} version {version}
from __future__ import annotations

from enum import Enum
from typing import Annotated, NewType, Optional, Union

import strawberry

"""


footer = ''
x = f"""
#resolve_pid: Callable[[strawberry.ID], Union[AllThings, None]] | None = None
#resolve_all: Callable[[], list[AllRecords]] | None = None
#resolve_records: Callable[[ClassNames], list[AllThings]] | None = None


def resolve_pid(pid: strawberry.ID) -> AllThings | None:
    if pid.lower().startswith('person'):
        return Person(
            pid=strawberry.ID(pid),
            given_name=f'John-{{pid}}',
        )
    elif pid.lower().startswith('agent'):
        return Agent(
            pid=strawberry.ID(pid),
            at_location=f'Berlin-{{pid}}',
        )
    else:
        return Thing(
            pid=strawberry.ID(pid),
            description=f'Thing description for {{pid}}',
        )


def resolve_all() -> list[AllRecords]:
    return [
        Agent(pid=strawberry.ID('agent-1'), at_location='Berlin'),
        Person(pid=strawberry.ID('person-1'), given_name='John'),
        Thing(pid=strawberry.ID('thing-1'), description='A sample thing'),
    ]


def resolve_records(class_name: ClassNames) -> list[AllThings]:
    return [
        Agent(pid=strawberry.ID('agent-1'), at_location=f'Berlin {{class_name}}'),
        Agent(pid=strawberry.ID('agent-2'), at_location=f'Berlin {{class_name}}'),
        Agent(pid=strawberry.ID('agent-3'), at_location=f'Berlin {{class_name}}'),
    ]


@strawberry.type
class Query:
    record: Optional[AllThings] = strawberry.field(resolver=resolve_pid)
    all: list[AllRecords] = strawberry.field(resolver=resolve_all)
    records: list[AllThings] = strawberry.field(resolver=resolve_records)


schema = strawberry.Schema(query=Query)
"""


@dataclass
class StrawberryGenerator(Generator):

    generatorname = os.path.basename(__file__)
    generatorversion = "0.0.1"
    valid_formats = ["graphql"]
    visit_all_class_slots = True
    uses_schemaloader = True
    requires_metamodel = False

    strict_naming: bool = False
    _permissible_value_valid_characters = re.compile("^[_A-Za-z][_0-9A-Za-z]*?$")

    def __post_init__(self):
        super().__post_init__()

    def visit_schema(self, **kwargs) -> str:

        # Fix for schema-bugs
        if 'ValueSpecificationMixin' in self.schema.classes:
            # This is a fix for the following issue:
            # <https://github.com/psychoinformatics-de/datalad-concepts/issues/299>
            self.schema.classes['ValueSpecificationMixin'].mixin = True

        # Check keyword arguments
        if 'item_definitions' not in kwargs:
            raise ValueError('missing keyword argument: `item_definitions`')
        self.item_definitions = kwargs['item_definitions']

        if 'header' not in kwargs:
            raise ValueError('missing keyword argument: `header`')
        self.header_lines = kwargs['header']

        # Create a union of all Things
        thing_subclasses = _get_subclasses(self.schema, 'Thing')
        thing_union = self._create_union(thing_union_name, thing_subclasses)

        # Create a union of all non-mixin classes
        record_union = self._create_union(record_union_name, [
            name
            for name, cls in self.schema.classes.items()
            if not cls.mixin
        ])

        header_lines = header_template.format(
            name=self.generatorname,
            version=self.generatorversion
        )
        self.header_lines.append(header_lines)

        return header_lines + thing_union + record_union

    def end_schema(self, **kwargs) -> str | None:
        result = (
            '@strawberry.enum\nclass ClassNames(Enum):\n    '
            + '\n    '.join(sorted(
                (
                    f'{name} = "{name}"' for name, info in self.schema.classes.items()
                    if not info.mixin
                )
            ))
            + '\n\n\n'
        )
        self.item_definitions['ClassNames'] = {
            'lines': [result],
            'dependencies': set(),
        }
        return result

    def visit_class(self, cls: ClassDefinition) -> str:
        self.item_definitions[cls.name] = {'lines': [], 'dependencies': set()}
        base = f'@strawberry.interface\n' if cls.mixin else f'@strawberry.type\n'
        base += f'class {cls.name}'
        if cls.mixins:
            self.item_definitions[cls.name]['dependencies'].update(cls.mixins)
            base += '(' + ', '.join(cls.mixins) + ')'

        result = base + ':\n'
        self.item_definitions[cls.name]['lines'].append(result)
        return result

    def end_class(self, cls: ClassDefinition) -> str:
        result = '\n\n'
        self.item_definitions[cls.name]['lines'].append(result)
        return result

    def visit_class_slot(
            self,
            cls: ClassDefinition,
            aliased_slot_name: str,
            slot: SlotDefinition
    ) -> str | None:
        if slot.identifier:
            type_spec = 'strawberry.ID'
        elif aliased_slot_name == 'relations' and slot.multivalued and slot.range == 'Thing':
            type_spec = f'"{thing_union_name}"'
        else:
            if slot.range in known_types:
                type_spec = known_types[slot.range]
            else:
                type_spec = f'"{slot.range}"'

        if slot.multivalued:
            type_spec = f'list[Optional[{type_spec}]]'
        if not slot.required:
            type_spec = f'Optional[{type_spec}] = None'
        result = f'    {aliased_slot_name}: {type_spec}\n'
        self.item_definitions[cls.name]['lines'].append(result)
        return result

    def visit_enum(self, enum: EnumDefinition) -> str | None:
        if not enum.permissible_values:
            msg = (
                f'Enumeration {enum.name} using `reachable_from` instead of '
                '`permissible_values` to specify permissible values is not '
                f'supported yet.'
            )
            raise ValueError(msg)

        result = (
            f'@strawberry.enum\nclass {enum.name}(Enum):\n    '
            + '\n    '.join(
                f'{v} = "{v}"' for v in enum.permissible_values
            )
            + '\n\n\n'
        )
        self.item_definitions[enum.name] = {
            'lines': [result],
            'dependencies': set(),
        }

    def visit_type(self, typ: TypeDefinition) -> str | None:
        if typ.name not in known_types:
            result = f'{typ.name} = strawberry.scalar(NewType("{typ.name}", object), serialize=lambda v: v, parse_value=lambda v: v)\n\n'
            self.item_definitions[typ.name] = {
                'lines': [result],
                'dependencies': set(),
            }
            return result

    def _create_union(self, union_name: str, items: list[str]) -> str:
        """
        Create a union type definition for the given items.
        """
        # Create a union of all non-mixin classes
        result = f'{union_name} = Annotated[\n{" " * 4}Union[\n{" " * 8}' + f'\n{" " * 8}'.join(
            f'"{item}",' for item in items
        ) + f'\n{" " * 4}],\n{" " * 4}strawberry.union(name="{union_name}"),\n]\n\n\n'
        self.item_definitions[union_name] = {
            'lines': [result],
            'dependencies': set(),
        }
        return result

def generate_strawberry_from_linkml(yaml_file: Path, **kwargs) -> str:
    generator = StrawberryGenerator(str(yaml_file))
    return generator.serialize(**kwargs)


def _get_subclasses(schema, super_class_name: str) -> list[str]:
    # A not very efficient algorithm to find all subclasses of a given class

    def super_classes(schema: SchemaDefinition, class_name: str):
        current_superclass = schema.classes[class_name].is_a
        while current_superclass:
            yield current_superclass
            current_superclass = schema.classes[current_superclass].is_a
        return

    return [
        class_name
        for class_name in schema.classes
        if super_class_name in super_classes(schema, class_name)
    ]


def _topological_sort(
    item_definitions: dict[str, dict[str, list[str]]]
) -> list[str]:
    """
    Get all slots that are inherited by the given class.
    """
    result = []

    # Create a simplified representation of item dependencies
    item_dependencies = {
        item_name: item_info['dependencies'].copy()
        for item_name, item_info in item_definitions.items()
    }

    # Sort the items topologically
    while item_dependencies:

        # Find all items that have no dependencies
        dependency_free = [
            item_name
            for item_name, dependencies in item_dependencies.items()
            if not dependencies
        ]

        if not dependency_free:
            raise ValueError("Circular dependency detected in LinkML schema.")

        result.extend(dependency_free)

        # Remove the dependency-free items from the list of items that have to
        # be sorted.
        for name in dependency_free:
            del item_dependencies[name]

        # Remove the dependency-free items from the dependency lists of the
        # remaining items.
        for dependency_list in item_dependencies.values():
            for name in dependency_list.copy():
                if name in result:
                    dependency_list.remove(name)

    return result


def get_strawberry_source(linkml_file: Path) -> str:
    """
    Generate a Strawberry module source from a LinkML schema file.
    """

    header = []
    item_definitions = {}
    generate_strawberry_from_linkml(
        linkml_file,
        header=header,
        item_definitions=item_definitions,
    )

    result = header
    sorted_items = _topological_sort(item_definitions)
    for name in sorted_items:
        info = item_definitions[name]
        result.extend(info['lines'])
    return ''.join(result) + footer


if __name__ == "__main__":
    source = get_strawberry_source(Path(sys.argv[1]))
    print(source)
