"""
Based on the LinkML GraphQL generator, this module generates a GraphQL schema
from a LinkML schema definition. It is specialized for use with the LinkML
schemata that are used by DataLad and INM7, that means:

- There is no name rewriting, all names are used as is.
- Identifier slots, i.e., `pid`, are always of type `ID`.
- There is a union of `Thing` and all its subclasses, named 'AllThings'.
  This is used in most places, where `Thing` is used in the LinkML schema.
- The `relations`-slots have the type 'AllThings'. This allows to inline
  objects.

"""
from __future__ import annotations

import logging
import os
import re
import sys
from dataclasses import dataclass

from linkml.utils.generator import Generator
from linkml_runtime.linkml_model import TypeDefinition, SchemaDefinition
from linkml_runtime.linkml_model.meta import ClassDefinition, EnumDefinition, SlotDefinition


# Mapping of schema types to Python types
known_types = {
    'string': 'str',
    'integer': 'int',
    'boolean': 'bool',
    'float': 'float',
}


union_name = 'AllThings'


query = f"""
type Query {{
    record(id: ID!): AllThings
    records(class: ClassNames, limit: Int, offset: Int): [AllThings!]!
}}
"""


@dataclass
class GraphQLGenerator(Generator):
    # ClassVars
    generatorname = os.path.basename(__file__)
    generatorversion = "0.0.1"
    valid_formats = ["graphql"]
    visit_all_class_slots = True
    uses_schemaloader = True
    requires_metamodel = False

    strict_naming: bool = False
    _permissible_value_valid_characters = re.compile("^[_A-Za-z][_0-9A-Za-z]*?$")

    def __post_init__(self):
        super().__post_init__()

    def visit_schema(self, **kwargs) -> str:
        # This is a fix for the following issue:
        # <https://github.com/psychoinformatics-de/datalad-concepts/issues/299>
        if 'ValueSpecificationMixin' in self.schema.classes:
            self.schema.classes['ValueSpecificationMixin'].mixin = True

        thing_subclasses = _get_subclasses(self.schema, 'Thing')
        return (
                f'# Generated by {self.generatorname} version {self.generatorversion}\n\n'
                f'union {union_name} = Thing | ' + ' | '.join(thing_subclasses) + '\n\n'
        )

    def end_schema(self, **kwargs) -> str | None:
        return (
                '@strawberry.enum\nclass ClassNames(Enum):\n    '
                + '\n    '.join(sorted(
            (
                class_name for class_name, class_info in self.schema.classes.items()
                if not class_info.mixin
            )
        )) + '\n}\n\n'
                + query
        )

    def visit_class(self, cls: ClassDefinition) -> str:
        base = f'@strawberry.interface\n' if cls.mixin else f'@strawberry.type\n'
        base += f'class {cls.name}'
        if cls.mixins:
            base += '(' + ', '.join(cls.mixins) + ')'
        return base + ':\n'

    def end_class(self, cls: ClassDefinition) -> str:
        return '\n\n'

    def visit_class_slot(
            self,
            cls: ClassDefinition,
            aliased_slot_name: str,
            slot: SlotDefinition
    ) -> str | None:

        if slot.owner != cls.name:
            # Skip slots that are not owned by the current class, which means it
            # was inherited. Let's not redefine it here.
            return None

        if slot.identifier:
            type_spec = 'strawberry.ID'
        elif aliased_slot_name == 'relations' and slot.multivalued and slot.range == 'Thing':
            type_spec = union_name
        else:
            type_spec = known_types.get(slot.range) or slot.range

        if slot.multivalued:
            type_spec = f'list[{type_spec} | None]'
        if not slot.required:
            type_spec += ' | None = None'
        return f'    {aliased_slot_name}: {type_spec}\n'

    def visit_enum(self, enum: EnumDefinition) -> str | None:
        if not enum.permissible_values:
            msg = (
                f'Enumeration {enum.name} using `reachable_from` instead of '
                '`permissible_values` to specify permissible values is not '
                f'supported yet.'
            )
            raise ValueError(msg)

        return (
            f'@strawberry.enum\nclass {enum.name}(Enum):\n'
            + '\n    '.join(
                f'{v} = "{v}"' for v in enum.permissible_values
            )
            + '\n\n'
        )

    def visit_type(self, typ: TypeDefinition) -> str | None:
        if typ.name not in known_types:
            return f'{typ.name} = strawberry.scalar(NewType("{typ.name}", object), serialize=lambda v: v, parse_value=lambda v: v)\n\n'
        return None


def generate_graphql_schema(yaml_file: str, **kwargs) -> str:
    generator = GraphQLGenerator(yaml_file)
    return generator.serialize(**kwargs)


def _get_subclasses(schema, super_class_name: str) -> list[str]:
    # A not very efficient algorithm to find all subclasses of a given class

    def super_classes(schema: SchemaDefinition, class_name: str):
        current_superclass = schema.classes[class_name].is_a
        while current_superclass:
            yield current_superclass
            current_superclass = schema.classes[current_superclass].is_a
        return

    return [
        class_name
        for class_name in schema.classes
        if super_class_name in super_classes(schema, class_name)
    ]


if __name__ == "__main__":
    x = generate_graphql_schema(sys.argv[1])
    print(x)
